#!/usr/bin/env python
from __future__ import print_function

import sys
import argparse
import numpy as np

# Data columns in the output
# This needs to be kept in sync with the columns in export-results, until
# this script and the expected results files are modified to run directly
# on the binary table outputs.
# Note that we load the flags as 'str', since that's what export-results
# does, but that doesn't matter since we're just comparing for equality
# for all non-float fields.
DTYPE = np.dtype(
    [("id", np.int64),
     ("coord_ra", float),
     ("coord_dec", float),
     ("flags_negative", str, 5),
     ("base_SdssCentroid_flag", str, 5),
     ("base_PixelFlags_flag_edge", str, 5),
     ("base_PixelFlags_flag_interpolated", str, 5),
     ("base_PixelFlags_flag_interpolatedCenter", str, 5),
     ("base_PixelFlags_flag_saturated", str, 5),
     ("base_PixelFlags_flag_saturatedCenter", str, 5),
     ("base_SdssCentroid_x", float),
     ("base_SdssCentroid_y", float),
     ("base_SdssCentroid_xSigma", float),
     ("base_SdssCentroid_ySigma", float),
     ("base_SdssShape_xx", float),
     ("base_SdssShape_xy", float),
     ("base_SdssShape_yy", float),
     ("base_SdssShape_xxSigma", float),
     ("base_SdssShape_xySigma", float),
     ("base_SdssShape_yySigma", float),
     ("base_SdssShape_flag", str, 5),
     ("base_GaussianFlux_flux", float),
     ("base_GaussianFlux_fluxSigma", float),
     ("base_PsfFlux_flux", float),
     ("base_PsfFlux_fluxSigma", float),
     ("base_CircularApertureFlux_2_flux", float),
     ("base_CircularApertureFlux_2_fluxSigma", float),
     ("base_ClassificationExtendedness_value", float),
     ])

def get_array(filename):
    with open(filename, 'r') as f:
        array = np.loadtxt(f, dtype=DTYPE)
    return array

def relDifference(arr1, arr2):
    """
    Compute the 'relative difference' of numpy arrays arr1 & arr2.

    The relative difference R between numbers n1 and n2 is defined as per
    numdiff (http://www.nongnu.org/numdiff/numdiff.html):
    * R = 0 if n1 and n2 are equal,
    * R = Inf if n2 differs from n1 and at least one of them is zero,
    * R = A/ min(|n1|, |n2|) if n1 and n2 are both non zero and n2 differs from n1.
    """
    absDiff = np.abs(arr1 - arr2)

    # If there is a difference between 0 and something else, the result is
    # infinite.
    absDiff = np.where((absDiff != 0) & ((arr1 == 0) | (arr2 == 0)), np.inf, absDiff)

    # If both inputs are nan, the result is 0.
    absDiff = np.where(np.isnan(arr1) & np.isnan(arr2), 0, absDiff)

    # If one input is nan, the result is infinite.
    absDiff = np.where(np.logical_xor(np.isnan(arr1), np.isnan(arr2)), np.inf, absDiff)

    # Divide by the minimum of the inputs, unless 0 or nan.
    # If the minimum is 0 or nan, then either both inputs are 0/nan (so there's no
    # difference) or one is 0/nan (in which case the absolute difference is
    # already inf).
    divisor = np.where(np.minimum(arr1, arr2) == 0, 1, np.minimum(arr1, arr2))
    divisor = np.where(np.isnan(divisor),  1, divisor)

    return absDiff/np.abs(divisor)

# Default tolerance chosen so that results measured on OS X 10.10.1,
# Ubuntu 14.04 and CentOS 6.6 are all regarded as consistent.
def compare(table1, table2, tolerance=4e-3):
    if table1.dtype != table2.dtype:
        print("Files do not have the same columns.")
        return False
    valid = True
    for name in table1.dtype.names:
        dtype, count = table1.dtype.fields[name]
        if dtype == np.dtype(float):
            maxDiff = relDifference(table1[name], table2[name]).max()
            if maxDiff > tolerance:
                print("Failed (max difference %f over tolerance %f) in column %s." %
                      (maxDiff, args.tolerance, name))
                valid = False
        else:
            if not np.all(table1[name] == table2[name]):
                nTotal = len(table1[name])
                nDiff = len(np.where(table1[name] != table2[name])[0])
                print("Failed (%s of %s flags do not match) in column %s." % (str(nDiff), str(nTotal), name))
                valid = False
    return valid

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('filename', nargs=2)
    parser.add_argument('--tolerance', default=4e-3, type=float)
    args = parser.parse_args()
    if compare(get_array(args.filename[0]), get_array(args.filename[1])):
        print("Ok.")
